import { Cbor, CborArray, CborBytes, CborTag, LazyCborArray } from "@harmoniclabs/cbor";
import { blake2b_256 } from "@harmoniclabs/crypto";
import { AllegraHeader, AlonzoHeader, BabbageHeader, ConwayHeader, MaryHeader, MultiEraHeader, ShelleyHeader } from "@harmoniclabs/cardano-ledger-ts";
import { ChainSyncRollForward } from "@harmoniclabs/ouroboros-miniprotocols-ts";
import { logger } from "../utils/logger";
import { calculateCardanoEpoch, calculatePreProdCardanoEpoch } from "./utils/epochCalculations";
import { validateHeader } from "../consensus/BlockHeaderValidator";
import { blockFrostFetchEra } from "./utils/blockFrostFetchEra";
import { fromHex } from "@harmoniclabs/uint8array-utils";
import { ShelleyGenesisConfig } from "../config/ShelleyGenesisTypes"
import { RawNewEpochState } from "../rawNES";
import { fetchBlock } from "./fetchBlocks";
import { putBlock } from "./lmdbWorkers/lmdb";
import { PeerClient } from "./PeerClient";

export async function validation(peer: PeerClient,  data: ChainSyncRollForward, shelleyGenesis: ShelleyGenesisConfig, lState: RawNewEpochState) {
    // ERA directly from Multiplxer ChainSyncRollForward the ERA Enum starts at 0.
    if (!(
        data.data instanceof CborArray
    )) throw new Error("invalid CBOR for header");
    const tipSlot = data.tip.point.blockHeader?.slotNumber;
    const blockHeaderData: Uint8Array = Cbor.encode(data.data).toBuffer();
    // logger.debug("blockHeaderData", toHex(blockHeaderData));
    const lazyHeader = Cbor.parseLazy(blockHeaderData);
    // logger.debug("Lazy Header: ", lazyHeader);
    if (!(
        lazyHeader instanceof LazyCborArray
    )) throw new Error("invalid CBOR for header");
    
    const blockHeaderParsed = Cbor.parse(lazyHeader.array[1]);
    // logger.debug("Block Header Parsed: ", blockHeaderParsed);
    if (!(
        blockHeaderParsed instanceof CborTag &&
        blockHeaderParsed.data instanceof CborBytes
    )) throw new Error("invalid CBOR for header body");

    const blockHeaderBodyLazy = Cbor.parseLazy(blockHeaderParsed.data.bytes);
    if (!(
        blockHeaderBodyLazy instanceof LazyCborArray
    )) throw new Error("invalid CBOR for header body");
    // logger.debug("Block Header Body Lazy: ", blockHeaderBodyLazy.array);
    /*
    * We add +1 to era in multiplexer because it enums starts at 0 for the HFC.
    */
    const blcokHeaderBodyEra = lazyHeader.array[0][0] + 1;
    // logger.debug("Header Era: ", blcokHeaderBodyEra);
    // Parse the header based on era
    let parsedHeader;
    switch (blcokHeaderBodyEra) {
        case 2:
            parsedHeader = ShelleyHeader.fromCbor(blockHeaderParsed.data.bytes);
            break;
        case 3:
            parsedHeader = AllegraHeader.fromCbor(blockHeaderParsed.data.bytes);
            break;
        case 4:
            parsedHeader = MaryHeader.fromCbor(blockHeaderParsed.data.bytes);
            break;
        case 5:
            parsedHeader = AlonzoHeader.fromCbor(blockHeaderParsed.data.bytes);
            break;
        case 6:
            parsedHeader = BabbageHeader.fromCbor(blockHeaderParsed.data.bytes);
            break;
        case 7:
            parsedHeader = ConwayHeader.fromCbor(blockHeaderParsed.data.bytes);
            break;
        default:
            return null;
    }
    // This is what I need for multiEraHeader
    const multiEraHeader = new MultiEraHeader({
        era: blcokHeaderBodyEra,
        header: parsedHeader,
    });
    // logger.debug("MultiEraHeader: ", multiEraHeader);

    const blockHeaderHash = blake2b_256(blockHeaderParsed.data.bytes);
    const headerEpoch = calculatePreProdCardanoEpoch(Number(multiEraHeader.header.body.slot));
    const epochNonce = await blockFrostFetchEra(headerEpoch as number);
    const slot = multiEraHeader.header.body.slot;
	    
    const validateHeaderRes = await validateHeader(multiEraHeader, fromHex(epochNonce.nonce), shelleyGenesis, lState);
    // logger.debug("Header validation result: ", validateHeaderRes);
    
    if (!validateHeaderRes) return;

    const block = await fetchBlock(peer, slot, blockHeaderHash);
    // logger.debug("Fetched block: ", block.blockData);
    if (block) {
        // Do Block Validation, then apply it to NES then save it to DB.
        await putBlock(blockHeaderHash, block.blockData); // Assuming block is MultiEraBlock; adjust if needed
        // logger.debug(`Stored block for hash ${blockHeaderHash} from peer ${peerId}`);
    } else {
        logger.error(`Failed to fetch block for hash ${blockHeaderHash} from peer ${peer.peerId}`);
        //return ({ slot, blockHeaderHash, multiEraHeader });
    };
}

//**
            // logger.debug("Validated header res: ", validateHeaderRes);
            
            /*This is just tempo for quick testing
            const blockPeerTest = this.allPeers.get(peerId);
            if (!blockPeerTest) return;
            const blockTest = await fetchBlock(blockPeerTest, 102379274, fromHex("9122f44b2848ff4bb91f872ee01636b666fd3418a87edbe0d9b70a2df417941d"));
            logger.debug("Test fetch block: ", blockTest.toCbor().toString());
            
            if (!validateHeaderRes)return;
            
            const tipSlot = data.tip.point.blockHeader?.slotNumber;
            const { slot, blockHeaderHash, multiEraHeader } = validateHeaderRes;
            // logger.debug("multiEraHeader: ", multiEraHeader.toCborBytes());
            // Store validated header in LMDB (as JSON) using worker
            // await putHeader(slot, blockHeaderHash, multiEraHeader.toCborBytes());
            // logger.debug(`Stored header for hash ${blockHeaderHash}`);
    
            const headerEpoch = calculatePreProdCardanoEpoch(Number(slot));
            logger.debug(`Validated - Era: ${multiEraHeader.era} - Epoch: ${headerEpoch} - Slot: ${slot} of ${tipSlot} - Percent Complete: ${((Number(slot) / Number(tipSlot)) * 100).toFixed(2) }%`);
    
            // Fetch and store the corresponding block
            const blockPeer = this.allPeers.get(peerId);
            if (!blockPeer) return;
            /**
             * Calculating block_body_hash
             * The block_body_hash is not a simple blake2b_256 hash of the entire serialized block body.
             * Instead, it is a Merkle root-like hash (often referred to as a "Merkle triple root" or quadruple root, depending on the era) of the key components of the block body.
             * This design allows for efficient verification of the block's contents (transactions, witnesses, metadata, etc.) without re-serializing the entire body,
             * while enabling segregated witness handling (introduced in the Alonzo era and carried forward).
             * blake2b_256(
                concatUint8Arr(
                    blake2b_256( tx_bodies ),
                    blake2b_256( tx_witnesses ),
                    blake2b_256( tx_metadatas ),
                    blake2b_256( tx_invalidTxsIdxs ),
                )
            )
            
            const block = await fetchBlock(blockPeer, slot, blockHeaderHash);
            // logger.debug("Fetched block: ", block.blockData);
            if (block) {
                await putBlock(blockHeaderHash, block.blockData); // Assuming block is MultiEraBlock; adjust if needed
                // logger.debug(`Stored block for hash ${blockHeaderHash} from peer ${peerId}`);
            } else {
                logger.error(`Failed to fetch block for hash ${blockHeaderHash} from peer ${peerId}`,
            );
*/
